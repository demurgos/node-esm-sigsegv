"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const incident_1 = require("incident");
const lazy_properties_1 = require("../_helpers/lazy-properties");
const invalid_type_1 = require("../errors/invalid-type");
const lazy_options_1 = require("../errors/lazy-options");
const not_implemented_1 = require("../errors/not-implemented");
const read_visitor_1 = require("../readers/read-visitor");
const test_error_1 = require("../test-error");
exports.name = "map";
class MapType {
    constructor(options) {
        this.name = exports.name;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazy_properties_1.lazyProperties(this, this._applyOptions, ["keyType", "valueType", "maxSize", "assumeStringKey"]);
        }
    }
    // TODO: Dynamically add with prototype?
    read(reader, raw) {
        if (this.assumeStringKey) {
            return reader.readDocument(raw, read_visitor_1.readVisitor({
                fromMap: (input, keyReader, valueReader) => {
                    const result = new Map();
                    for (const [rawKey, rawValue] of input) {
                        const uncheckedKey = keyReader.readString(rawKey, read_visitor_1.readVisitor({ fromString: (input) => input }));
                        const keyErr = this.keyType.testError(uncheckedKey);
                        if (keyErr !== undefined) {
                            throw keyErr;
                        }
                        const key = uncheckedKey;
                        let value;
                        try {
                            value = this.valueType.read(valueReader, rawValue);
                        }
                        catch (err) {
                            throw err;
                        }
                        result.set(key, value);
                    }
                    const error = this.testError(result);
                    if (error !== undefined) {
                        throw error;
                    }
                    return result;
                },
            }));
        }
        return reader.readMap(raw, read_visitor_1.readVisitor({
            fromMap: (input, keyReader, valueReader) => {
                const result = new Map();
                for (const [rawKey, rawValue] of input) {
                    const key = this.keyType.read(keyReader, rawKey);
                    const value = this.valueType.read(valueReader, rawValue);
                    result.set(key, value);
                }
                const error = this.testError(result);
                if (error !== undefined) {
                    throw error;
                }
                return result;
            },
        }));
    }
    // TODO: Dynamically add with prototype?
    write(writer, value) {
        if (this.assumeStringKey) {
            return writer.writeDocument(value.keys(), (outKey, fieldWriter) => {
                return this.valueType.write(fieldWriter, value.get(outKey));
            });
        }
        const entries = [...value];
        return writer.writeMap(entries.length, (index, keyWriter) => {
            if (this.keyType.write === undefined) {
                throw new incident_1.Incident("NotWritable", { type: this.keyType });
            }
            return this.keyType.write(keyWriter, entries[index][0]);
        }, (index, valueWriter) => {
            if (this.valueType.write === undefined) {
                throw new incident_1.Incident("NotWritable", { type: this.valueType });
            }
            return this.valueType.write(valueWriter, entries[index][1]);
        });
    }
    testError(val) {
        if (!(val instanceof Map)) {
            return invalid_type_1.createInvalidTypeError("Map", val);
        }
        for (const [key, value] of val) {
            const keyError = test_error_1.testError(this.keyType, key);
            if (keyError !== undefined) {
                return new incident_1.Incident("InvalidMapKey", { key, value }, "Invalid map entry: invalid key");
            }
            const valueError = test_error_1.testError(this.valueType, value);
            if (valueError !== undefined) {
                return new incident_1.Incident("InvalidMapValue", { key, value }, "Invalid map entry: invalid value");
            }
        }
        return undefined;
    }
    test(val) {
        if (!(val instanceof Map)) {
            return false;
        }
        for (const [key, value] of val) {
            if (!this.keyType.test(key) || !this.valueType.test(value)) {
                return false;
            }
        }
        return true;
    }
    equals(val1, val2) {
        if (val2.size !== val1.size) {
            return false;
        }
        const unmatched = new Map(val1);
        for (const [key2, value2] of val2) {
            for (const [key1, value1] of unmatched) {
                if (this.keyType.equals(key1, key2)) {
                    if (!this.valueType.equals(value1, value2)) {
                        return false;
                    }
                    unmatched.delete(key1);
                    break;
                }
            }
        }
        return true;
    }
    clone(val) {
        const result = new Map();
        for (const [key, value] of val) {
            const keyClone = this.keyType.clone(key);
            const valueClone = this.valueType.clone(value);
            result.set(keyClone, valueClone);
        }
        return result;
    }
    diff(_oldVal, _newVal) {
        throw not_implemented_1.createNotImplementedError("MapType#diff");
    }
    patch(_oldVal, _diff) {
        throw not_implemented_1.createNotImplementedError("MapType#patch");
    }
    reverseDiff(_diff) {
        throw not_implemented_1.createNotImplementedError("MapType#reverseDiff");
    }
    squash(_diff1, _diff2) {
        throw not_implemented_1.createNotImplementedError("MapType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw lazy_options_1.createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const keyType = options.keyType;
        const valueType = options.valueType;
        const maxSize = options.maxSize;
        const assumeStringKey = options.assumeStringKey || false;
        Object.assign(this, { keyType, valueType, maxSize, assumeStringKey });
    }
}
exports.MapType = MapType;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdHlwZXMvbWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsdUNBQW9DO0FBQ3BDLGlFQUE2RDtBQUU3RCx5REFBZ0U7QUFDaEUseURBQWdFO0FBQ2hFLCtEQUFzRTtBQUN0RSwwREFBc0Q7QUFDdEQsOENBQTBDO0FBRzdCLFFBQUEsSUFBSSxHQUFTLEtBQUssQ0FBQztBQVVoQyxNQUFhLE9BQU87SUFTbEIsWUFBWSxPQUFtQztRQVJ0QyxTQUFJLEdBQVMsWUFBSSxDQUFDO1FBU3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUN0QjthQUFNO1lBQ0wsZ0NBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQztTQUNsRztJQUNILENBQUM7SUFFRCx3Q0FBd0M7SUFDeEMsSUFBSSxDQUFJLE1BQWlCLEVBQUUsR0FBTTtRQUMvQixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSwwQkFBVyxDQUFDO2dCQUMxQyxPQUFPLEVBQUUsQ0FBUyxLQUFrQixFQUFFLFNBQXFCLEVBQUUsV0FBdUIsRUFBYSxFQUFFO29CQUNqRyxNQUFNLE1BQU0sR0FBYyxJQUFJLEdBQUcsRUFBRSxDQUFDO29CQUVwQyxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUksS0FBSyxFQUFFO3dCQUN0QyxNQUFNLFlBQVksR0FBVyxTQUFTLENBQUMsVUFBVSxDQUMvQyxNQUFNLEVBQ04sMEJBQVcsQ0FBQyxFQUFDLFVBQVUsRUFBRSxDQUFDLEtBQWEsRUFBVSxFQUFFLENBQUMsS0FBSyxFQUFDLENBQUMsQ0FD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QixPQUFPLENBQUMsU0FBUyxDQUFDO1FBQzNELE1BQU0sT0FBTyxHQUFXLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDeEMsTUFBTSxlQUFlLEdBQVksT0FBTyxDQUFDLGVBQWUsSUFBSSxLQUFLLENBQUM7UUFFbEUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDRjtBQTNMRCwwQkEyTEMiLCJmaWxlIjoibGliL3R5cGVzL21hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluY2lkZW50IH0gZnJvbSBcImluY2lkZW50XCI7XG5pbXBvcnQgeyBsYXp5UHJvcGVydGllcyB9IGZyb20gXCIuLi9faGVscGVycy9sYXp5LXByb3BlcnRpZXNcIjtcbmltcG9ydCB7IElvVHlwZSwgTGF6eSwgUmVhZGVyLCBWZXJzaW9uZWRUeXBlLCBXcml0ZXIgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZFR5cGVFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMvaW52YWxpZC10eXBlXCI7XG5pbXBvcnQgeyBjcmVhdGVMYXp5T3B0aW9uc0Vycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy9sYXp5LW9wdGlvbnNcIjtcbmltcG9ydCB7IGNyZWF0ZU5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzL25vdC1pbXBsZW1lbnRlZFwiO1xuaW1wb3J0IHsgcmVhZFZpc2l0b3IgfSBmcm9tIFwiLi4vcmVhZGVycy9yZWFkLXZpc2l0b3JcIjtcbmltcG9ydCB7IHRlc3RFcnJvciB9IGZyb20gXCIuLi90ZXN0LWVycm9yXCI7XG5cbmV4cG9ydCB0eXBlIE5hbWUgPSBcIm1hcFwiO1xuZXhwb3J0IGNvbnN0IG5hbWU6IE5hbWUgPSBcIm1hcFwiO1xuZXhwb3J0IHR5cGUgRGlmZiA9IGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXBUeXBlT3B0aW9uczxLLCBWPiB7XG4gIGtleVR5cGU6IFZlcnNpb25lZFR5cGU8SywgYW55PjtcbiAgdmFsdWVUeXBlOiBWZXJzaW9uZWRUeXBlPFYsIGFueT47XG4gIG1heFNpemU6IG51bWJlcjtcbiAgYXNzdW1lU3RyaW5nS2V5PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIE1hcFR5cGU8SywgVj4gaW1wbGVtZW50cyBJb1R5cGU8TWFwPEssIFY+PiwgVmVyc2lvbmVkVHlwZTxNYXA8SywgVj4sIERpZmY+IHtcbiAgcmVhZG9ubHkgbmFtZTogTmFtZSA9IG5hbWU7XG4gIHJlYWRvbmx5IGtleVR5cGUhOiBWZXJzaW9uZWRUeXBlPEssIGFueT47XG4gIHJlYWRvbmx5IHZhbHVlVHlwZSE6IFZlcnNpb25lZFR5cGU8ViwgYW55PjtcbiAgcmVhZG9ubHkgbWF4U2l6ZSE6IG51bWJlcjtcbiAgcmVhZG9ubHkgYXNzdW1lU3RyaW5nS2V5ITogYm9vbGVhbjtcblxuICBwcml2YXRlIF9vcHRpb25zOiBMYXp5PE1hcFR5cGVPcHRpb25zPEssIFY+PjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBMYXp5PE1hcFR5cGVPcHRpb25zPEssIFY+Pikge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9hcHBseU9wdGlvbnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF6eVByb3BlcnRpZXModGhpcywgdGhpcy5fYXBwbHlPcHRpb25zLCBbXCJrZXlUeXBlXCIsIFwidmFsdWVUeXBlXCIsIFwibWF4U2l6ZVwiLCBcImFzc3VtZVN0cmluZ0tleVwiXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogRHluYW1pY2FsbHkgYWRkIHdpdGggcHJvdG90eXBlP1xuICByZWFkPFI+KHJlYWRlcjogUmVhZGVyPFI+LCByYXc6IFIpOiBNYXA8SywgVj4ge1xuICAgIGlmICh0aGlzLmFzc3VtZVN0cmluZ0tleSkge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRG9jdW1lbnQocmF3LCByZWFkVmlzaXRvcih7XG4gICAgICAgIGZyb21NYXA6IDxSSywgUlY+KGlucHV0OiBNYXA8UkssIFJWPiwga2V5UmVhZGVyOiBSZWFkZXI8Uks+LCB2YWx1ZVJlYWRlcjogUmVhZGVyPFJWPik6IE1hcDxLLCBWPiA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0OiBNYXA8SywgVj4gPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IFtyYXdLZXksIHJhd1ZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgdW5jaGVja2VkS2V5OiBzdHJpbmcgPSBrZXlSZWFkZXIucmVhZFN0cmluZyhcbiAgICAgICAgICAgICAgcmF3S2V5LFxuICAgICAgICAgICAgICByZWFkVmlzaXRvcih7ZnJvbVN0cmluZzogKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgPT4gaW5wdXR9KSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBrZXlFcnI6IEVycm9yIHwgdW5kZWZpbmVkID0gdGhpcy5rZXlUeXBlLnRlc3RFcnJvciEodW5jaGVja2VkS2V5IGFzIGFueSk7XG4gICAgICAgICAgICBpZiAoa2V5RXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cga2V5RXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5OiBLID0gdW5jaGVja2VkS2V5IGFzIGFueTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTogVjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZVR5cGUucmVhZCEodmFsdWVSZWFkZXIsIHJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHRoaXMudGVzdEVycm9yKHJlc3VsdCk7XG4gICAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkZXIucmVhZE1hcChyYXcsIHJlYWRWaXNpdG9yKHtcbiAgICAgIGZyb21NYXA6IDxSSywgUlY+KGlucHV0OiBNYXA8UkssIFJWPiwga2V5UmVhZGVyOiBSZWFkZXI8Uks+LCB2YWx1ZVJlYWRlcjogUmVhZGVyPFJWPik6IE1hcDxLLCBWPiA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogTWFwPEssIFY+ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtyYXdLZXksIHJhd1ZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IGtleTogSyA9IHRoaXMua2V5VHlwZS5yZWFkIShrZXlSZWFkZXIsIHJhd0tleSk7XG4gICAgICAgICAgY29uc3QgdmFsdWU6IFYgPSB0aGlzLnZhbHVlVHlwZS5yZWFkISh2YWx1ZVJlYWRlciwgcmF3VmFsdWUpO1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdGhpcy50ZXN0RXJyb3IocmVzdWx0KTtcbiAgICAgICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cblxuICAvLyBUT0RPOiBEeW5hbWljYWxseSBhZGQgd2l0aCBwcm90b3R5cGU/XG4gIHdyaXRlPFc+KHdyaXRlcjogV3JpdGVyPFc+LCB2YWx1ZTogTWFwPEssIFY+KTogVyB7XG4gICAgaWYgKHRoaXMuYXNzdW1lU3RyaW5nS2V5KSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlRG9jdW1lbnQoXG4gICAgICAgIHZhbHVlLmtleXMoKSBhcyBJdGVyYWJsZTxhbnk+IGFzIEl0ZXJhYmxlPHN0cmluZz4sXG4gICAgICAgIDxGVz4ob3V0S2V5OiBzdHJpbmcsIGZpZWxkV3JpdGVyOiBXcml0ZXI8Rlc+KTogRlcgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlVHlwZS53cml0ZSEoZmllbGRXcml0ZXIsIHZhbHVlLmdldChvdXRLZXkgYXMgYW55KSEpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyaWVzOiBbSywgVl1bXSA9IFsuLi52YWx1ZV07XG5cbiAgICByZXR1cm4gd3JpdGVyLndyaXRlTWFwKFxuICAgICAgZW50cmllcy5sZW5ndGgsXG4gICAgICA8S1c+KGluZGV4OiBudW1iZXIsIGtleVdyaXRlcjogV3JpdGVyPEtXPik6IEtXID0+IHtcbiAgICAgICAgaWYgKHRoaXMua2V5VHlwZS53cml0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEluY2lkZW50KFwiTm90V3JpdGFibGVcIiwge3R5cGU6IHRoaXMua2V5VHlwZX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleVR5cGUud3JpdGUoa2V5V3JpdGVyLCBlbnRyaWVzW2luZGV4XVswXSk7XG4gICAgICB9LFxuICAgICAgPFZXPihpbmRleDogbnVtYmVyLCB2YWx1ZVdyaXRlcjogV3JpdGVyPFZXPik6IFZXID0+IHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVUeXBlLndyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW5jaWRlbnQoXCJOb3RXcml0YWJsZVwiLCB7dHlwZTogdGhpcy52YWx1ZVR5cGV9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVR5cGUud3JpdGUodmFsdWVXcml0ZXIsIGVudHJpZXNbaW5kZXhdWzFdKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHRlc3RFcnJvcih2YWw6IE1hcDxLLCBWPik6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSW52YWxpZFR5cGVFcnJvcihcIk1hcFwiLCB2YWwpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwpIHtcbiAgICAgIGNvbnN0IGtleUVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHRlc3RFcnJvcih0aGlzLmtleVR5cGUsIGtleSk7XG4gICAgICBpZiAoa2V5RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IEluY2lkZW50KFwiSW52YWxpZE1hcEtleVwiLCB7a2V5LCB2YWx1ZX0sIFwiSW52YWxpZCBtYXAgZW50cnk6IGludmFsaWQga2V5XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQgPSB0ZXN0RXJyb3IodGhpcy52YWx1ZVR5cGUsIHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmNpZGVudChcIkludmFsaWRNYXBWYWx1ZVwiLCB7a2V5LCB2YWx1ZX0sIFwiSW52YWxpZCBtYXAgZW50cnk6IGludmFsaWQgdmFsdWVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB0ZXN0KHZhbDogTWFwPEssIFY+KTogYm9vbGVhbiB7XG4gICAgaWYgKCEodmFsIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwpIHtcbiAgICAgIGlmICghdGhpcy5rZXlUeXBlLnRlc3Qoa2V5KSB8fCAhdGhpcy52YWx1ZVR5cGUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVxdWFscyh2YWwxOiBNYXA8SywgVj4sIHZhbDI6IE1hcDxLLCBWPik6IGJvb2xlYW4ge1xuICAgIGlmICh2YWwyLnNpemUgIT09IHZhbDEuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB1bm1hdGNoZWQ6IE1hcDxLLCBWPiA9IG5ldyBNYXAodmFsMSk7XG4gICAgZm9yIChjb25zdCBba2V5MiwgdmFsdWUyXSBvZiB2YWwyKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXkxLCB2YWx1ZTFdIG9mIHVubWF0Y2hlZCkge1xuICAgICAgICBpZiAodGhpcy5rZXlUeXBlLmVxdWFscyhrZXkxLCBrZXkyKSkge1xuICAgICAgICAgIGlmICghdGhpcy52YWx1ZVR5cGUuZXF1YWxzKHZhbHVlMSwgdmFsdWUyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bm1hdGNoZWQuZGVsZXRlKGtleTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2xvbmUodmFsOiBNYXA8SywgVj4pOiBNYXA8SywgVj4ge1xuICAgIGNvbnN0IHJlc3VsdDogTWFwPEssIFY+ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbCkge1xuICAgICAgY29uc3Qga2V5Q2xvbmU6IEsgPSB0aGlzLmtleVR5cGUuY2xvbmUoa2V5KTtcbiAgICAgIGNvbnN0IHZhbHVlQ2xvbmU6IFYgPSB0aGlzLnZhbHVlVHlwZS5jbG9uZSh2YWx1ZSk7XG4gICAgICByZXN1bHQuc2V0KGtleUNsb25lLCB2YWx1ZUNsb25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRpZmYoX29sZFZhbDogTWFwPEssIFY+LCBfbmV3VmFsOiBNYXA8SywgVj4pOiBEaWZmIHwgdW5kZWZpbmVkIHtcbiAgICB0aHJvdyBjcmVhdGVOb3RJbXBsZW1lbnRlZEVycm9yKFwiTWFwVHlwZSNkaWZmXCIpO1xuICB9XG5cbiAgcGF0Y2goX29sZFZhbDogTWFwPEssIFY+LCBfZGlmZjogRGlmZiB8IHVuZGVmaW5lZCk6IE1hcDxLLCBWPiB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIk1hcFR5cGUjcGF0Y2hcIik7XG4gIH1cblxuICByZXZlcnNlRGlmZihfZGlmZjogRGlmZiB8IHVuZGVmaW5lZCk6IERpZmYgfCB1bmRlZmluZWQge1xuICAgIHRocm93IGNyZWF0ZU5vdEltcGxlbWVudGVkRXJyb3IoXCJNYXBUeXBlI3JldmVyc2VEaWZmXCIpO1xuICB9XG5cbiAgc3F1YXNoKF9kaWZmMTogRGlmZiB8IHVuZGVmaW5lZCwgX2RpZmYyOiBEaWZmIHwgdW5kZWZpbmVkKTogRGlmZiB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIk1hcFR5cGUjc3F1YXNoXCIpO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXBwbHlPcHRpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNyZWF0ZUxhenlPcHRpb25zRXJyb3IodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnM6IE1hcFR5cGVPcHRpb25zPEssIFY+ID0gdHlwZW9mIHRoaXMuX29wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX29wdGlvbnMoKSA6IHRoaXMuX29wdGlvbnM7XG5cbiAgICBjb25zdCBrZXlUeXBlOiBWZXJzaW9uZWRUeXBlPEssIGFueT4gPSBvcHRpb25zLmtleVR5cGU7XG4gICAgY29uc3QgdmFsdWVUeXBlOiBWZXJzaW9uZWRUeXBlPFYsIGFueT4gPSBvcHRpb25zLnZhbHVlVHlwZTtcbiAgICBjb25zdCBtYXhTaXplOiBudW1iZXIgPSBvcHRpb25zLm1heFNpemU7XG4gICAgY29uc3QgYXNzdW1lU3RyaW5nS2V5OiBib29sZWFuID0gb3B0aW9ucy5hc3N1bWVTdHJpbmdLZXkgfHwgZmFsc2U7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtrZXlUeXBlLCB2YWx1ZVR5cGUsIG1heFNpemUsIGFzc3VtZVN0cmluZ0tleX0pO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
