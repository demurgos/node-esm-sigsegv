import { Incident } from "incident";
import { lazyProperties } from "../_helpers/lazy-properties";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createNotImplementedError } from "../errors/not-implemented";
import { readVisitor } from "../readers/read-visitor";
import { testError } from "../test-error";
export const name = "map";
export class MapType {
    constructor(options) {
        this.name = name;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["keyType", "valueType", "maxSize", "assumeStringKey"]);
        }
    }
    // TODO: Dynamically add with prototype?
    read(reader, raw) {
        if (this.assumeStringKey) {
            return reader.readDocument(raw, readVisitor({
                fromMap: (input, keyReader, valueReader) => {
                    const result = new Map();
                    for (const [rawKey, rawValue] of input) {
                        const uncheckedKey = keyReader.readString(rawKey, readVisitor({ fromString: (input) => input }));
                        const keyErr = this.keyType.testError(uncheckedKey);
                        if (keyErr !== undefined) {
                            throw keyErr;
                        }
                        const key = uncheckedKey;
                        let value;
                        try {
                            value = this.valueType.read(valueReader, rawValue);
                        }
                        catch (err) {
                            throw err;
                        }
                        result.set(key, value);
                    }
                    const error = this.testError(result);
                    if (error !== undefined) {
                        throw error;
                    }
                    return result;
                },
            }));
        }
        return reader.readMap(raw, readVisitor({
            fromMap: (input, keyReader, valueReader) => {
                const result = new Map();
                for (const [rawKey, rawValue] of input) {
                    const key = this.keyType.read(keyReader, rawKey);
                    const value = this.valueType.read(valueReader, rawValue);
                    result.set(key, value);
                }
                const error = this.testError(result);
                if (error !== undefined) {
                    throw error;
                }
                return result;
            },
        }));
    }
    // TODO: Dynamically add with prototype?
    write(writer, value) {
        if (this.assumeStringKey) {
            return writer.writeDocument(value.keys(), (outKey, fieldWriter) => {
                return this.valueType.write(fieldWriter, value.get(outKey));
            });
        }
        const entries = [...value];
        return writer.writeMap(entries.length, (index, keyWriter) => {
            if (this.keyType.write === undefined) {
                throw new Incident("NotWritable", { type: this.keyType });
            }
            return this.keyType.write(keyWriter, entries[index][0]);
        }, (index, valueWriter) => {
            if (this.valueType.write === undefined) {
                throw new Incident("NotWritable", { type: this.valueType });
            }
            return this.valueType.write(valueWriter, entries[index][1]);
        });
    }
    testError(val) {
        if (!(val instanceof Map)) {
            return createInvalidTypeError("Map", val);
        }
        for (const [key, value] of val) {
            const keyError = testError(this.keyType, key);
            if (keyError !== undefined) {
                return new Incident("InvalidMapKey", { key, value }, "Invalid map entry: invalid key");
            }
            const valueError = testError(this.valueType, value);
            if (valueError !== undefined) {
                return new Incident("InvalidMapValue", { key, value }, "Invalid map entry: invalid value");
            }
        }
        return undefined;
    }
    test(val) {
        if (!(val instanceof Map)) {
            return false;
        }
        for (const [key, value] of val) {
            if (!this.keyType.test(key) || !this.valueType.test(value)) {
                return false;
            }
        }
        return true;
    }
    equals(val1, val2) {
        if (val2.size !== val1.size) {
            return false;
        }
        const unmatched = new Map(val1);
        for (const [key2, value2] of val2) {
            for (const [key1, value1] of unmatched) {
                if (this.keyType.equals(key1, key2)) {
                    if (!this.valueType.equals(value1, value2)) {
                        return false;
                    }
                    unmatched.delete(key1);
                    break;
                }
            }
        }
        return true;
    }
    clone(val) {
        const result = new Map();
        for (const [key, value] of val) {
            const keyClone = this.keyType.clone(key);
            const valueClone = this.valueType.clone(value);
            result.set(keyClone, valueClone);
        }
        return result;
    }
    diff(_oldVal, _newVal) {
        throw createNotImplementedError("MapType#diff");
    }
    patch(_oldVal, _diff) {
        throw createNotImplementedError("MapType#patch");
    }
    reverseDiff(_diff) {
        throw createNotImplementedError("MapType#reverseDiff");
    }
    squash(_diff1, _diff2) {
        throw createNotImplementedError("MapType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const keyType = options.keyType;
        const valueType = options.valueType;
        const maxSize = options.maxSize;
        const assumeStringKey = options.assumeStringKey || false;
        Object.assign(this, { keyType, valueType, maxSize, assumeStringKey });
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdHlwZXMvbWFwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDcEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTdELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzFDLE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBUyxLQUFLLENBQUM7QUFVaEMsTUFBTSxPQUFPLE9BQU87SUFTbEIsWUFBWSxPQUFtQztRQVJ0QyxTQUFJLEdBQVMsSUFBSSxDQUFDO1FBU3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUN0QjthQUFNO1lBQ0wsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1NBQ2xHO0lBQ0gsQ0FBQztJQUVELHdDQUF3QztJQUN4QyxJQUFJLENBQUksTUFBaUIsRUFBRSxHQUFNO1FBQy9CLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixPQUFPLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQztnQkFDMUMsT0FBTyxFQUFFLENBQVMsS0FBa0IsRUFBRSxTQUFxQixFQUFFLFdBQXVCLEVBQWEsRUFB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QkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNwQztRQUNELE1BQU0sT0FBTyxHQUF5QixPQUFPLElBQUksQ0FBQyxRQUFRLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFNUcsTUFBTSxPQUFPLEdBQTBCLE9BQU8sQ0FBQyxPQUFPLENBQUM7UUFDdkQsTUFBTSxTQUFTLEdBQTBCLE9BQU8sQ0FBQyxTQUFTLENBQUM7UUFDM0QsTUFBTSxPQUFPLEdBQVcsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUN4QyxNQUFNLGVBQWUsR0FBWSxPQUFPLENBQUMsZUFBZSxJQUFJLEtBQUssQ0FBQztRQUVsRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBQyxDQUFDLENBQUM7SUFDdEUsQ0FBQztDQUNGIiwiZmlsZSI6ImxpYi90eXBlcy9tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmNpZGVudCB9IGZyb20gXCJpbmNpZGVudFwiO1xuaW1wb3J0IHsgbGF6eVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vX2hlbHBlcnMvbGF6eS1wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBJb1R5cGUsIExhenksIFJlYWRlciwgVmVyc2lvbmVkVHlwZSwgV3JpdGVyIH0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IGNyZWF0ZUludmFsaWRUeXBlRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzL2ludmFsaWQtdHlwZVwiO1xuaW1wb3J0IHsgY3JlYXRlTGF6eU9wdGlvbnNFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMvbGF6eS1vcHRpb25zXCI7XG5pbXBvcnQgeyBjcmVhdGVOb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy9ub3QtaW1wbGVtZW50ZWRcIjtcbmltcG9ydCB7IHJlYWRWaXNpdG9yIH0gZnJvbSBcIi4uL3JlYWRlcnMvcmVhZC12aXNpdG9yXCI7XG5pbXBvcnQgeyB0ZXN0RXJyb3IgfSBmcm9tIFwiLi4vdGVzdC1lcnJvclwiO1xuXG5leHBvcnQgdHlwZSBOYW1lID0gXCJtYXBcIjtcbmV4cG9ydCBjb25zdCBuYW1lOiBOYW1lID0gXCJtYXBcIjtcbmV4cG9ydCB0eXBlIERpZmYgPSBhbnk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwVHlwZU9wdGlvbnM8SywgVj4ge1xuICBrZXlUeXBlOiBWZXJzaW9uZWRUeXBlPEssIGFueT47XG4gIHZhbHVlVHlwZTogVmVyc2lvbmVkVHlwZTxWLCBhbnk+O1xuICBtYXhTaXplOiBudW1iZXI7XG4gIGFzc3VtZVN0cmluZ0tleT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBNYXBUeXBlPEssIFY+IGltcGxlbWVudHMgSW9UeXBlPE1hcDxLLCBWPj4sIFZlcnNpb25lZFR5cGU8TWFwPEssIFY+LCBEaWZmPiB7XG4gIHJlYWRvbmx5IG5hbWU6IE5hbWUgPSBuYW1lO1xuICByZWFkb25seSBrZXlUeXBlITogVmVyc2lvbmVkVHlwZTxLLCBhbnk+O1xuICByZWFkb25seSB2YWx1ZVR5cGUhOiBWZXJzaW9uZWRUeXBlPFYsIGFueT47XG4gIHJlYWRvbmx5IG1heFNpemUhOiBudW1iZXI7XG4gIHJlYWRvbmx5IGFzc3VtZVN0cmluZ0tleSE6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3B0aW9uczogTGF6eTxNYXBUeXBlT3B0aW9uczxLLCBWPj47XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogTGF6eTxNYXBUeXBlT3B0aW9uczxLLCBWPj4pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5fYXBwbHlPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhenlQcm9wZXJ0aWVzKHRoaXMsIHRoaXMuX2FwcGx5T3B0aW9ucywgW1wia2V5VHlwZVwiLCBcInZhbHVlVHlwZVwiLCBcIm1heFNpemVcIiwgXCJhc3N1bWVTdHJpbmdLZXlcIl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IER5bmFtaWNhbGx5IGFkZCB3aXRoIHByb3RvdHlwZT9cbiAgcmVhZDxSPihyZWFkZXI6IFJlYWRlcjxSPiwgcmF3OiBSKTogTWFwPEssIFY+IHtcbiAgICBpZiAodGhpcy5hc3N1bWVTdHJpbmdLZXkpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZERvY3VtZW50KHJhdywgcmVhZFZpc2l0b3Ioe1xuICAgICAgICBmcm9tTWFwOiA8UkssIFJWPihpbnB1dDogTWFwPFJLLCBSVj4sIGtleVJlYWRlcjogUmVhZGVyPFJLPiwgdmFsdWVSZWFkZXI6IFJlYWRlcjxSVj4pOiBNYXA8SywgVj4gPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdDogTWFwPEssIFY+ID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBbcmF3S2V5LCByYXdWYWx1ZV0gb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuY2hlY2tlZEtleTogc3RyaW5nID0ga2V5UmVhZGVyLnJlYWRTdHJpbmcoXG4gICAgICAgICAgICAgIHJhd0tleSxcbiAgICAgICAgICAgICAgcmVhZFZpc2l0b3Ioe2Zyb21TdHJpbmc6IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IGlucHV0fSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qga2V5RXJyOiBFcnJvciB8IHVuZGVmaW5lZCA9IHRoaXMua2V5VHlwZS50ZXN0RXJyb3IhKHVuY2hlY2tlZEtleSBhcyBhbnkpO1xuICAgICAgICAgICAgaWYgKGtleUVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IGtleUVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleTogSyA9IHVuY2hlY2tlZEtleSBhcyBhbnk7XG4gICAgICAgICAgICBsZXQgdmFsdWU6IFY7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVUeXBlLnJlYWQhKHZhbHVlUmVhZGVyLCByYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQgPSB0aGlzLnRlc3RFcnJvcihyZXN1bHQpO1xuICAgICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZGVyLnJlYWRNYXAocmF3LCByZWFkVmlzaXRvcih7XG4gICAgICBmcm9tTWFwOiA8UkssIFJWPihpbnB1dDogTWFwPFJLLCBSVj4sIGtleVJlYWRlcjogUmVhZGVyPFJLPiwgdmFsdWVSZWFkZXI6IFJlYWRlcjxSVj4pOiBNYXA8SywgVj4gPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQ6IE1hcDxLLCBWPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbcmF3S2V5LCByYXdWYWx1ZV0gb2YgaW5wdXQpIHtcbiAgICAgICAgICBjb25zdCBrZXk6IEsgPSB0aGlzLmtleVR5cGUucmVhZCEoa2V5UmVhZGVyLCByYXdLZXkpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlOiBWID0gdGhpcy52YWx1ZVR5cGUucmVhZCEodmFsdWVSZWFkZXIsIHJhd1ZhbHVlKTtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHRoaXMudGVzdEVycm9yKHJlc3VsdCk7XG4gICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gVE9ETzogRHluYW1pY2FsbHkgYWRkIHdpdGggcHJvdG90eXBlP1xuICB3cml0ZTxXPih3cml0ZXI6IFdyaXRlcjxXPiwgdmFsdWU6IE1hcDxLLCBWPik6IFcge1xuICAgIGlmICh0aGlzLmFzc3VtZVN0cmluZ0tleSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZURvY3VtZW50KFxuICAgICAgICB2YWx1ZS5rZXlzKCkgYXMgSXRlcmFibGU8YW55PiBhcyBJdGVyYWJsZTxzdHJpbmc+LFxuICAgICAgICA8Rlc+KG91dEtleTogc3RyaW5nLCBmaWVsZFdyaXRlcjogV3JpdGVyPEZXPik6IEZXID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVR5cGUud3JpdGUhKGZpZWxkV3JpdGVyLCB2YWx1ZS5nZXQob3V0S2V5IGFzIGFueSkhKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZW50cmllczogW0ssIFZdW10gPSBbLi4udmFsdWVdO1xuXG4gICAgcmV0dXJuIHdyaXRlci53cml0ZU1hcChcbiAgICAgIGVudHJpZXMubGVuZ3RoLFxuICAgICAgPEtXPihpbmRleDogbnVtYmVyLCBrZXlXcml0ZXI6IFdyaXRlcjxLVz4pOiBLVyA9PiB7XG4gICAgICAgIGlmICh0aGlzLmtleVR5cGUud3JpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbmNpZGVudChcIk5vdFdyaXRhYmxlXCIsIHt0eXBlOiB0aGlzLmtleVR5cGV9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5rZXlUeXBlLndyaXRlKGtleVdyaXRlciwgZW50cmllc1tpbmRleF1bMF0pO1xuICAgICAgfSxcbiAgICAgIDxWVz4oaW5kZXg6IG51bWJlciwgdmFsdWVXcml0ZXI6IFdyaXRlcjxWVz4pOiBWVyA9PiB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlVHlwZS53cml0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEluY2lkZW50KFwiTm90V3JpdGFibGVcIiwge3R5cGU6IHRoaXMudmFsdWVUeXBlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUeXBlLndyaXRlKHZhbHVlV3JpdGVyLCBlbnRyaWVzW2luZGV4XVsxXSk7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICB0ZXN0RXJyb3IodmFsOiBNYXA8SywgVj4pOiBFcnJvciB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCEodmFsIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWRUeXBlRXJyb3IoXCJNYXBcIiwgdmFsKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsKSB7XG4gICAgICBjb25zdCBrZXlFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQgPSB0ZXN0RXJyb3IodGhpcy5rZXlUeXBlLCBrZXkpO1xuICAgICAgaWYgKGtleUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmNpZGVudChcIkludmFsaWRNYXBLZXlcIiwge2tleSwgdmFsdWV9LCBcIkludmFsaWQgbWFwIGVudHJ5OiBpbnZhbGlkIGtleVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlRXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkID0gdGVzdEVycm9yKHRoaXMudmFsdWVUeXBlLCB2YWx1ZSk7XG4gICAgICBpZiAodmFsdWVFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5jaWRlbnQoXCJJbnZhbGlkTWFwVmFsdWVcIiwge2tleSwgdmFsdWV9LCBcIkludmFsaWQgbWFwIGVudHJ5OiBpbnZhbGlkIHZhbHVlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGVzdCh2YWw6IE1hcDxLLCBWPik6IGJvb2xlYW4ge1xuICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsKSB7XG4gICAgICBpZiAoIXRoaXMua2V5VHlwZS50ZXN0KGtleSkgfHwgIXRoaXMudmFsdWVUeXBlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlcXVhbHModmFsMTogTWFwPEssIFY+LCB2YWwyOiBNYXA8SywgVj4pOiBib29sZWFuIHtcbiAgICBpZiAodmFsMi5zaXplICE9PSB2YWwxLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdW5tYXRjaGVkOiBNYXA8SywgVj4gPSBuZXcgTWFwKHZhbDEpO1xuICAgIGZvciAoY29uc3QgW2tleTIsIHZhbHVlMl0gb2YgdmFsMikge1xuICAgICAgZm9yIChjb25zdCBba2V5MSwgdmFsdWUxXSBvZiB1bm1hdGNoZWQpIHtcbiAgICAgICAgaWYgKHRoaXMua2V5VHlwZS5lcXVhbHMoa2V5MSwga2V5MikpIHtcbiAgICAgICAgICBpZiAoIXRoaXMudmFsdWVUeXBlLmVxdWFscyh2YWx1ZTEsIHZhbHVlMikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tYXRjaGVkLmRlbGV0ZShrZXkxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNsb25lKHZhbDogTWFwPEssIFY+KTogTWFwPEssIFY+IHtcbiAgICBjb25zdCByZXN1bHQ6IE1hcDxLLCBWPiA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwpIHtcbiAgICAgIGNvbnN0IGtleUNsb25lOiBLID0gdGhpcy5rZXlUeXBlLmNsb25lKGtleSk7XG4gICAgICBjb25zdCB2YWx1ZUNsb25lOiBWID0gdGhpcy52YWx1ZVR5cGUuY2xvbmUodmFsdWUpO1xuICAgICAgcmVzdWx0LnNldChrZXlDbG9uZSwgdmFsdWVDbG9uZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBkaWZmKF9vbGRWYWw6IE1hcDxLLCBWPiwgX25ld1ZhbDogTWFwPEssIFY+KTogRGlmZiB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIk1hcFR5cGUjZGlmZlwiKTtcbiAgfVxuXG4gIHBhdGNoKF9vbGRWYWw6IE1hcDxLLCBWPiwgX2RpZmY6IERpZmYgfCB1bmRlZmluZWQpOiBNYXA8SywgVj4ge1xuICAgIHRocm93IGNyZWF0ZU5vdEltcGxlbWVudGVkRXJyb3IoXCJNYXBUeXBlI3BhdGNoXCIpO1xuICB9XG5cbiAgcmV2ZXJzZURpZmYoX2RpZmY6IERpZmYgfCB1bmRlZmluZWQpOiBEaWZmIHwgdW5kZWZpbmVkIHtcbiAgICB0aHJvdyBjcmVhdGVOb3RJbXBsZW1lbnRlZEVycm9yKFwiTWFwVHlwZSNyZXZlcnNlRGlmZlwiKTtcbiAgfVxuXG4gIHNxdWFzaChfZGlmZjE6IERpZmYgfCB1bmRlZmluZWQsIF9kaWZmMjogRGlmZiB8IHVuZGVmaW5lZCk6IERpZmYgfCB1bmRlZmluZWQge1xuICAgIHRocm93IGNyZWF0ZU5vdEltcGxlbWVudGVkRXJyb3IoXCJNYXBUeXBlI3NxdWFzaFwiKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5T3B0aW9ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBjcmVhdGVMYXp5T3B0aW9uc0Vycm9yKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zOiBNYXBUeXBlT3B0aW9uczxLLCBWPiA9IHR5cGVvZiB0aGlzLl9vcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9vcHRpb25zKCkgOiB0aGlzLl9vcHRpb25zO1xuXG4gICAgY29uc3Qga2V5VHlwZTogVmVyc2lvbmVkVHlwZTxLLCBhbnk+ID0gb3B0aW9ucy5rZXlUeXBlO1xuICAgIGNvbnN0IHZhbHVlVHlwZTogVmVyc2lvbmVkVHlwZTxWLCBhbnk+ID0gb3B0aW9ucy52YWx1ZVR5cGU7XG4gICAgY29uc3QgbWF4U2l6ZTogbnVtYmVyID0gb3B0aW9ucy5tYXhTaXplO1xuICAgIGNvbnN0IGFzc3VtZVN0cmluZ0tleTogYm9vbGVhbiA9IG9wdGlvbnMuYXNzdW1lU3RyaW5nS2V5IHx8IGZhbHNlO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7a2V5VHlwZSwgdmFsdWVUeXBlLCBtYXhTaXplLCBhc3N1bWVTdHJpbmdLZXl9KTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
