import { lazyProperties } from "../_helpers/lazy-properties";
import { createInvalidFloat64Error } from "../errors/invalid-float64";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { readVisitor } from "../readers/read-visitor";
export const name = "float64";
export class Float64Type {
    constructor(options) {
        this.name = name;
        this._options = options !== undefined ? options : {};
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["allowNaN", "allowInfinity"]);
        }
    }
    static fromJSON(options) {
        return new Float64Type(options);
    }
    toJSON() {
        return {
            name,
            allowNaN: this.allowNaN,
            allowInfinity: this.allowInfinity,
        };
    }
    read(reader, raw) {
        return reader.readFloat64(raw, readVisitor({
            fromFloat64: (input) => {
                const error = reader.trustInput ? undefined : this.testError(input);
                if (error !== undefined) {
                    throw error;
                }
                return input;
            },
        }));
    }
    // TODO: Dynamically add with prototype?
    write(writer, value) {
        return writer.writeFloat64(value);
    }
    testError(val) {
        if (typeof val !== "number") {
            return createInvalidTypeError("number", val);
        }
        if (isNaN(val) && !this.allowNaN) {
            return createInvalidFloat64Error(val);
        }
        else if (Math.abs(val) === Infinity && !this.allowInfinity) {
            return createInvalidFloat64Error(val);
        }
        return undefined;
    }
    test(val) {
        return typeof val === "number"
            && (this.allowNaN || !isNaN(val))
            && (this.allowInfinity || Math.abs(val) !== Infinity);
    }
    /**
     * Tests the equivalence of two valid float64 values.
     *
     * Two values are equivalent if they are both `NaN`, both `-0`, both `+0` or non-zero and
     * numerically equal.
     */
    equals(left, right) {
        return Object.is(left, right);
    }
    /**
     * Compares two valid float64 values.
     *
     * The values are ordered as follow:
     * - `-Infinity`
     * - Negative non-zero finite values
     * - `-0`
     * - `+0`
     * - Positive non-zero finite values
     * - `+Infinity`
     * - `NaN`
     *
     * @param left Left operand.
     * @param right Right operand.
     * @return Boolean indicating if `left <= right`
     */
    lte(left, right) {
        if (isNaN(right)) {
            return true;
        }
        else if (isNaN(left)) {
            return false;
        }
        if (left === 0 && right === 0) {
            return Object.is(left, -0) || Object.is(right, +0);
        }
        return left <= right;
    }
    clone(value) {
        return value;
    }
    diff(oldVal, newVal) {
        // We can't use an arithmetic difference due to possible precision loss
        return this.equals(oldVal, newVal) ? undefined : [oldVal, newVal];
    }
    patch(oldVal, diff) {
        return diff === undefined ? oldVal : diff[1];
    }
    reverseDiff(diff) {
        return diff === undefined ? undefined : [diff[1], diff[0]];
    }
    squash(diff1, diff2) {
        if (diff1 === undefined) {
            return diff2 === undefined ? undefined : [diff2[0], diff2[1]];
        }
        else if (diff2 === undefined) {
            return [diff1[0], diff1[1]];
        }
        return this.equals(diff1[0], diff2[1]) ? undefined : [diff1[0], diff2[1]];
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const allowNaN = options.allowNaN !== undefined ? options.allowNaN : false;
        const allowInfinity = options.allowInfinity !== undefined ? options.allowInfinity : false;
        Object.assign(this, { allowNaN, allowInfinity });
    }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdHlwZXMvZmxvYXQ2NC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFN0QsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDdEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDaEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBR3RELE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBUyxTQUFTLENBQUM7QUErQnBDLE1BQU0sT0FBTyxXQUFXO0lBT3RCLFlBQVksT0FBa0M7UUFOckMsU0FBSSxHQUFTLElBQUksQ0FBQztRQU96QixJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3JELElBQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUN0QjthQUFNO1lBQ0wsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUM7U0FDekU7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFrQjtRQUNoQyxPQUFPLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNO1FBQ0osT0FBTztZQUNMLElBQUk7WUFDSixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhO1NBQ2xDLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxDQUFJLE1BQWlCLEVBQUUsR0FBTTtRQUMvQixP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T0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNwRixNQUFNLGFBQWEsR0FBWSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBRW5HLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUMsUUFBUSxFQUFFLGFBQWEsRUFBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztDQUNGIiwiZmlsZSI6ImxpYi90eXBlcy9mbG9hdDY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGF6eVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vX2hlbHBlcnMvbGF6eS1wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBJb1R5cGUsIExhenksIE9yZCwgUmVhZGVyLCBWZXJzaW9uZWRUeXBlLCBXcml0ZXIgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZEZsb2F0NjRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMvaW52YWxpZC1mbG9hdDY0XCI7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkVHlwZUVycm9yIH0gZnJvbSBcIi4uL2Vycm9ycy9pbnZhbGlkLXR5cGVcIjtcbmltcG9ydCB7IGNyZWF0ZUxhenlPcHRpb25zRXJyb3IgfSBmcm9tIFwiLi4vZXJyb3JzL2xhenktb3B0aW9uc1wiO1xuaW1wb3J0IHsgcmVhZFZpc2l0b3IgfSBmcm9tIFwiLi4vcmVhZGVycy9yZWFkLXZpc2l0b3JcIjtcblxuZXhwb3J0IHR5cGUgTmFtZSA9IFwiZmxvYXQ2NFwiO1xuZXhwb3J0IGNvbnN0IG5hbWU6IE5hbWUgPSBcImZsb2F0NjRcIjtcbmV4cG9ydCBuYW1lc3BhY2UganNvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgVHlwZSB7XG4gICAgcmVhZG9ubHkgbmFtZTogTmFtZTtcbiAgICByZWFkb25seSBhbGxvd05hTjogYm9vbGVhbjtcbiAgICByZWFkb25seSBhbGxvd0luZmluaXR5OiBib29sZWFuO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGBGbG9hdDY0YCBtZXRhLXR5cGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvYXQ2NFR5cGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEFjY2VwdCBgTmFOYCB2YWx1ZXMuXG4gICAqIElmIHlvdSBlbmFibGUgdGhpcyBvcHRpb24sIHRoZSBgdGVzdGAgbWV0aG9kIHdpbGwgdHJlYXQgdHdvIGBOYU5gIHZhbHVlcyBhcyBlcXVhbC5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dOYU4/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBY2NlcHQgYCtJbmZpbml0eWAgYW5kIGAtSW5maW5pdHlgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICByZWFkb25seSBhbGxvd0luZmluaXR5PzogYm9vbGVhbjtcblxuICAvLyBUT0RPOiBBZGQgYHVuaWZ5WmVyb3NgIChkZWZhdWx0cyB0byBgdHJ1ZWApIHRvIGhhbmRsZSBgKzBgIGFuZCBgLTBgXG59XG5cbmV4cG9ydCBjbGFzcyBGbG9hdDY0VHlwZSBpbXBsZW1lbnRzIElvVHlwZTxudW1iZXI+LCBWZXJzaW9uZWRUeXBlPG51bWJlciwgW251bWJlciwgbnVtYmVyXT4sIE9yZDxudW1iZXI+IHtcbiAgcmVhZG9ubHkgbmFtZTogTmFtZSA9IG5hbWU7XG4gIHJlYWRvbmx5IGFsbG93TmFOITogYm9vbGVhbjtcbiAgcmVhZG9ubHkgYWxsb3dJbmZpbml0eSE6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3B0aW9uczogTGF6eTxGbG9hdDY0VHlwZU9wdGlvbnM+O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBMYXp5PEZsb2F0NjRUeXBlT3B0aW9ucz4pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucyA6IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLl9hcHBseU9wdGlvbnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF6eVByb3BlcnRpZXModGhpcywgdGhpcy5fYXBwbHlPcHRpb25zLCBbXCJhbGxvd05hTlwiLCBcImFsbG93SW5maW5pdHlcIl0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihvcHRpb25zOiBqc29uLlR5cGUpOiBGbG9hdDY0VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0VHlwZShvcHRpb25zKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBqc29uLlR5cGUge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgYWxsb3dOYU46IHRoaXMuYWxsb3dOYU4sXG4gICAgICBhbGxvd0luZmluaXR5OiB0aGlzLmFsbG93SW5maW5pdHksXG4gICAgfTtcbiAgfVxuXG4gIHJlYWQ8Uj4ocmVhZGVyOiBSZWFkZXI8Uj4sIHJhdzogUik6IG51bWJlciB7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkRmxvYXQ2NChyYXcsIHJlYWRWaXNpdG9yKHtcbiAgICAgIGZyb21GbG9hdDY0OiAoaW5wdXQ6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCA9IHJlYWRlci50cnVzdElucHV0ID8gdW5kZWZpbmVkIDogdGhpcy50ZXN0RXJyb3IoaW5wdXQpO1xuICAgICAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gVE9ETzogRHluYW1pY2FsbHkgYWRkIHdpdGggcHJvdG90eXBlP1xuICB3cml0ZTxXPih3cml0ZXI6IFdyaXRlcjxXPiwgdmFsdWU6IG51bWJlcik6IFcge1xuICAgIHJldHVybiB3cml0ZXIud3JpdGVGbG9hdDY0KHZhbHVlKTtcbiAgfVxuXG4gIHRlc3RFcnJvcih2YWw6IG51bWJlcik6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWRUeXBlRXJyb3IoXCJudW1iZXJcIiwgdmFsKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHZhbCkgJiYgIXRoaXMuYWxsb3dOYU4pIHtcbiAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkRmxvYXQ2NEVycm9yKHZhbCk7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID09PSBJbmZpbml0eSAmJiAhdGhpcy5hbGxvd0luZmluaXR5KSB7XG4gICAgICByZXR1cm4gY3JlYXRlSW52YWxpZEZsb2F0NjRFcnJvcih2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGVzdCh2YWw6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiXG4gICAgICAmJiAodGhpcy5hbGxvd05hTiB8fCAhaXNOYU4odmFsKSlcbiAgICAgICYmICh0aGlzLmFsbG93SW5maW5pdHkgfHwgTWF0aC5hYnModmFsKSAhPT0gSW5maW5pdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIHRoZSBlcXVpdmFsZW5jZSBvZiB0d28gdmFsaWQgZmxvYXQ2NCB2YWx1ZXMuXG4gICAqXG4gICAqIFR3byB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQgaWYgdGhleSBhcmUgYm90aCBgTmFOYCwgYm90aCBgLTBgLCBib3RoIGArMGAgb3Igbm9uLXplcm8gYW5kXG4gICAqIG51bWVyaWNhbGx5IGVxdWFsLlxuICAgKi9cbiAgZXF1YWxzKGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBPYmplY3QuaXMobGVmdCwgcmlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byB2YWxpZCBmbG9hdDY0IHZhbHVlcy5cbiAgICpcbiAgICogVGhlIHZhbHVlcyBhcmUgb3JkZXJlZCBhcyBmb2xsb3c6XG4gICAqIC0gYC1JbmZpbml0eWBcbiAgICogLSBOZWdhdGl2ZSBub24temVybyBmaW5pdGUgdmFsdWVzXG4gICAqIC0gYC0wYFxuICAgKiAtIGArMGBcbiAgICogLSBQb3NpdGl2ZSBub24temVybyBmaW5pdGUgdmFsdWVzXG4gICAqIC0gYCtJbmZpbml0eWBcbiAgICogLSBgTmFOYFxuICAgKlxuICAgKiBAcGFyYW0gbGVmdCBMZWZ0IG9wZXJhbmQuXG4gICAqIEBwYXJhbSByaWdodCBSaWdodCBvcGVyYW5kLlxuICAgKiBAcmV0dXJuIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBgbGVmdCA8PSByaWdodGBcbiAgICovXG4gIGx0ZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoaXNOYU4ocmlnaHQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKGxlZnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZWZ0ID09PSAwICYmIHJpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmlzKGxlZnQsIC0wKSB8fCBPYmplY3QuaXMocmlnaHQsICswKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gIH1cblxuICBjbG9uZSh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBkaWZmKG9sZFZhbDogbnVtYmVyLCBuZXdWYWw6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQge1xuICAgIC8vIFdlIGNhbid0IHVzZSBhbiBhcml0aG1ldGljIGRpZmZlcmVuY2UgZHVlIHRvIHBvc3NpYmxlIHByZWNpc2lvbiBsb3NzXG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKG9sZFZhbCwgbmV3VmFsKSA/IHVuZGVmaW5lZCA6IFtvbGRWYWwsIG5ld1ZhbF07XG4gIH1cblxuICBwYXRjaChvbGRWYWw6IG51bWJlciwgZGlmZjogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRpZmYgPT09IHVuZGVmaW5lZCA/IG9sZFZhbCA6IGRpZmZbMV07XG4gIH1cblxuICByZXZlcnNlRGlmZihkaWZmOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkKTogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGRpZmYgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFtkaWZmWzFdLCBkaWZmWzBdXTtcbiAgfVxuXG4gIHNxdWFzaChkaWZmMTogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCwgZGlmZjI6IFtudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWQpOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoZGlmZjEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRpZmYyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBbZGlmZjJbMF0sIGRpZmYyWzFdXTtcbiAgICB9IGVsc2UgaWYgKGRpZmYyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbZGlmZjFbMF0sIGRpZmYxWzFdXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKGRpZmYxWzBdLCBkaWZmMlsxXSkgPyB1bmRlZmluZWQgOiBbZGlmZjFbMF0sIGRpZmYyWzFdXTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5T3B0aW9ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBjcmVhdGVMYXp5T3B0aW9uc0Vycm9yKHRoaXMpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zOiBGbG9hdDY0VHlwZU9wdGlvbnMgPSB0eXBlb2YgdGhpcy5fb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fb3B0aW9ucygpIDogdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhbGxvd05hTjogYm9vbGVhbiA9IG9wdGlvbnMuYWxsb3dOYU4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxsb3dOYU4gOiBmYWxzZTtcbiAgICBjb25zdCBhbGxvd0luZmluaXR5OiBib29sZWFuID0gb3B0aW9ucy5hbGxvd0luZmluaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFsbG93SW5maW5pdHkgOiBmYWxzZTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge2FsbG93TmFOLCBhbGxvd0luZmluaXR5fSk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
